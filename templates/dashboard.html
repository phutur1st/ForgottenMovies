{% extends "base.html" %}

{% block extra_head %}
<style>
    #todo-card,
    #recent-card,
    #unsubscribe-card {
        scroll-margin-top: 110px;
    }
    .actions-col {
        width: 70px;
        text-align: right;
    }
    .actions-cell {
        text-align: right;
        white-space: nowrap;
    }
    .action-menu {
        position: relative;
        display: inline-block;
    }
    .menu-trigger {
        background: none;
        border: none;
        color: #c5cae9;
        font-size: 1.25rem;
        padding: 0.1rem 0.4rem;
        border-radius: 999px;
        cursor: pointer;
    }
    .menu-trigger:hover {
        color: #ffcc80;
    }
    .menu-trigger:focus-visible {
        outline: 2px solid #7986cb;
        outline-offset: 2px;
    }
    .action-menu.open .menu-trigger {
        color: #ffcc80;
    }
    .menu-dropdown {
        position: absolute;
        top: 110%;
        right: 0;
        background: #2a2a2a;
        border-radius: 8px;
        min-width: 160px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        padding: 0.35rem 0;
        display: none;
        z-index: 20;
    }
    .menu-dropdown form {
        margin: 0;
    }
    .action-menu.open .menu-dropdown {
        display: block;
    }
    .menu-item-button {
        width: 100%;
        background: none;
        border: none;
        color: #e0e0e0;
        text-align: left;
        padding: 0.5rem 0.9rem;
        font-size: 0.95rem;
        cursor: pointer;
    }
    .menu-item-button:hover,
    .menu-item-button:focus {
        background: rgba(63, 81, 181, 0.35);
        color: #ffffff;
        outline: none;
    }
    .menu-item-button.confirming {
        background: rgba(229, 115, 115, 0.35);
        color: #ffccbc;
    }
    .table-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
    }
    .table-controls .table-meta {
        font-weight: 600;
        color: #c5cae9;
    }
    .table-search {
        padding: 0.4rem 0.6rem;
        border: 1px solid #555;
        border-radius: 4px;
        background: #2a2a2a;
        color: #e0e0e0;
        font-size: 0.9rem;
        min-width: 200px;
    }
    .table-search:focus {
        outline: 2px solid #7986cb;
        outline-offset: 1px;
        border-color: #7986cb;
    }
    .table-search::placeholder {
        color: #888;
    }
    .filter-dropdown {
        position: relative;
        display: inline-block;
    }
    .filter-trigger {
        background: none;
        border: none;
        color: #c5cae9;
        cursor: pointer;
        padding: 0.2rem 0.4rem;
        margin-left: 0.3rem;
        border-radius: 3px;
        font-size: 0.85rem;
    }
    .filter-trigger:hover {
        background: rgba(121, 134, 203, 0.2);
    }
    .filter-trigger.active {
        color: #ffcc80;
        background: rgba(255, 204, 128, 0.15);
    }
    .filter-menu {
        position: absolute;
        top: 100%;
        left: 0;
        background: #2a2a2a;
        border: 1px solid #555;
        border-radius: 6px;
        min-width: 220px;
        max-width: 400px;
        max-height: 350px;
        overflow-y: auto;
        overflow-x: hidden;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        padding: 0.5rem;
        display: none;
        z-index: 1000;
        margin-top: 0.25rem;
    }
    @media (max-width: 768px) {
        .filter-menu {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            max-width: 90vw;
            max-height: 70vh;
        }
    }
    .filter-dropdown.open .filter-menu {
        display: block;
    }
    .filter-menu-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 0.5rem;
        margin-bottom: 0.5rem;
        border-bottom: 1px solid #444;
    }
    .filter-menu-header button {
        background: none;
        border: none;
        color: #7986cb;
        cursor: pointer;
        font-size: 0.85rem;
        padding: 0.2rem 0.4rem;
    }
    .filter-menu-header button:hover {
        color: #ffcc80;
        text-decoration: underline;
    }
    .filter-option {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.4rem 0.5rem;
        cursor: pointer;
        user-select: none;
        border-radius: 4px;
        transition: background 0.15s ease;
    }
    .filter-option:hover {
        background: rgba(121, 134, 203, 0.2);
    }
    .filter-option input[type="checkbox"] {
        cursor: pointer;
        flex-shrink: 0;
        width: 16px;
        height: 16px;
    }
    .filter-option label {
        cursor: pointer;
        flex: 1;
        font-size: 0.9rem;
        color: #e0e0e0;
        overflow: hidden;
        text-overflow: ellipsis;
        word-break: break-word;
        line-height: 1.4;
    }
    th.sortable {
        white-space: nowrap;
    }
    .filter-backdrop {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
    }
    .filter-backdrop.active {
        display: block;
    }
    @media (max-width: 768px) {
        .filter-dropdown.open .filter-menu {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
    }
    .filter-menu::-webkit-scrollbar {
        width: 8px;
    }
    .filter-menu::-webkit-scrollbar-track {
        background: #1a1a1a;
        border-radius: 4px;
    }
    .filter-menu::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
    }
    .filter-menu::-webkit-scrollbar-thumb:hover {
        background: #666;
    }
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }
    .hidden {
        display: none !important;
    }
</style>
{% endblock %}

{% block content %}
{% if scheduler_disabled %}
<div class="message info">
    <span>Scheduler is currently disabled. Automated API calls and emails are paused.</span>
    <a href="{{ url_for('settings') }}" style="color:#c5cae9; text-decoration: underline;">Enable in Settings</a>
</div>
{% endif %}
<div class="card" id="run-now-card">
    <h2>Run Now</h2>
    <p>Kick off the Forgotten Movies check immediately instead of waiting for the next schedule.</p>
    <p>This will first check overseerr for new requests then check tautulli for unwatched old requests and then email users.</p>
    <form method="post" action="{{ url_for('run_now') }}">
        <button type="submit">Run Job Now</button>
    </form>
</div>
<div class="card" id="todo-card">
    <h2>Upcoming Reminders</h2>
    {% if todo_messages %}
    <div class="local-flashes">
        {% for category, text in todo_messages %}
        <div class="message {{ category|replace('todo-', '') }}">
            <span>{{ text }}</span>
            <button type="button" class="close-btn" aria-label="Dismiss">&times;</button>
        </div>
        {% endfor %}
    </div>
    {% endif %}
    {% if todo_items %}
    <div class="table-controls" data-table="todo-table">
        <div class="table-meta"><span class="filtered-count">{{ todo_items|length }}</span> / {{ todo_items|length }} total</div>
        <label>
            <input type="text" class="table-search" data-table="todo-table" placeholder="Search...">
        </label>
        <label>Rows per page:
            <select class="page-size" data-table="todo-table">
                <option value="5">5</option>
                <option value="10" selected>10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">All</option>
            </select>
        </label>
        <div class="pager" data-table="todo-table">
            <button type="button" class="prev">Prev</button>
            <span class="page-info"></span>
            <button type="button" class="next">Next</button>
        </div>
    </div>
    <div class="table-wrapper">
        <table id="todo-table">
            <thead>
                <tr>
                    <th class="sortable" data-sort-type="text">Title</th>
                    <th class="sortable" data-sort-type="text">Media</th>
                    <th class="sortable" data-sort-type="text">Plex User</th>
                    <th class="sortable" data-sort-type="text">Email</th>
                    <th class="sortable" data-sort-type="date">Media Added</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for item in todo_items %}
                <tr>
                    <td>{{ item.title }}</td>
                    <td>{{ item.media_type|title }}</td>
                    <td>{{ item.plex_username }}</td>
                    <td>{{ item.email }}</td>
                    <td data-sort-value="{{ item.media_added_sort }}">{{ item.created_at_display }}</td>
                    <td class="actions-cell">
                        <div class="action-menu">
                            <button type="button" class="menu-trigger" aria-haspopup="true" aria-expanded="false">
                                <span class="sr-only">Actions</span>&#8942;
                            </button>
                            <div class="menu-dropdown" role="menu">
                                <form method="post" action="{{ url_for('skip_request', request_id=item.id) }}" class="menu-item-form">
                                    <button type="submit" class="menu-item-button" role="menuitem" data-double-confirm="true" data-second-text="Are you sure?">Don't Send</button>
                                </form>
                                <form method="post" action="{{ url_for('send_request_now', request_id=item.id) }}" class="menu-item-form">
                                    <button type="submit" class="menu-item-button" role="menuitem" data-double-confirm="true" data-second-text="Are you sure?">Send Now</button>
                                </form>
                            </div>
                        </div>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% else %}
        <p>All caught up! No reminders are queued right now.</p>
    {% endif %}
</div>
<div class="card">
    <h2>Sent Emails</h2>
    {% if recent_messages %}
    <div class="local-flashes">
        {% for category, text in recent_messages %}
        <div class="message {{ category|replace('recent-', '') }}">
            <span>{{ text }}</span>
            <button type="button" class="close-btn" aria-label="Dismiss">&times;</button>
        </div>
        {% endfor %}
    </div>
    {% endif %}
    {% if recent_emails %}
    <div class="table-controls" data-table="recent-table">
        <div class="table-meta"><span class="filtered-count">{{ recent_emails|length }}</span> / {{ recent_emails|length }} total</div>
        <label>
            <input type="text" class="table-search" data-table="recent-table" placeholder="Search...">
        </label>
        <label>Rows per page:
            <select class="page-size" data-table="recent-table">
                <option value="5">5</option>
                <option value="10" selected>10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">All</option>
            </select>
        </label>
        <div class="pager" data-table="recent-table">
            <button type="button" class="prev">Prev</button>
            <span class="page-info"></span>
            <button type="button" class="next">Next</button>
        </div>
    </div>
    <div class="table-wrapper">
        <table id="recent-table">
            <thead>
                <tr>
                    <th class="sortable" data-sort-type="text">Title</th>
                    <th class="sortable" data-sort-type="text">Media</th>
                    <th class="sortable" data-sort-type="text">Plex User</th>
                    <th class="sortable" data-sort-type="text">Email</th>
                    <th class="sortable" data-sort-type="date">Media Added</th>
                    <th class="sortable" data-sort-type="date">Sent At</th>
                    <th class="sortable" data-sort-type="date">Date Watched</th>
                </tr>
            </thead>
            <tbody>
                {% for item in recent_emails %}
                <tr>
                    <td>{{ item.title }}</td>
                    <td>{{ item.media_type|title }}</td>
                    <td>{{ item.plex_username }}</td>
                    <td>{{ item.email }}</td>
                    <td data-sort-value="{{ item.media_added_sort }}">{{ item.media_added_display }}</td>
                    <td data-sort-value="{{ item.email_sent_at_sort }}">{{ item.email_sent_at_display }}</td>
                    <td data-sort-value="{{ item.date_watched_sort }}">{{ item.date_watched_display }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% else %}
        <p>No reminder emails have been sent yet.</p>
    {% endif %}
</div>
<div class="card" id="unsubscribe-card">
    <h2>Manage Unsubscribed Emails</h2>
    {% if unsubscribe_messages %}
    <div class="local-flashes">
        {% for category, text in unsubscribe_messages %}
        <div class="message {{ category|replace('unsubscribe-', '') }}">
            <span>{{ text }}</span>
            <button type="button" class="close-btn" aria-label="Dismiss">&times;</button>
        </div>
        {% endfor %}
    </div>
    {% endif %}
    <form id="unsubscribe-form" method="post" action="{{ url_for('unsubscribe_email') }}">
        <input type="email" name="email" id="unsubscribe-email-input" placeholder="Email address" required>
        <button type="submit">Unsubscribe</button>
    </form>
<div class="table-controls" data-table="unsubscribe-table" {% if not unsubscribe_records %}style="display:none;"{% endif %}>
    <div class="table-meta"><span class="filtered-count">{{ unsubscribe_records|length }}</span> / <span id="unsubscribe-count">{{ unsubscribe_records|length }}</span> total</div>
    <label>
        <input type="text" class="table-search" data-table="unsubscribe-table" placeholder="Search...">
    </label>
    <label>Rows per page:
        <select class="page-size" data-table="unsubscribe-table">
            <option value="5">5</option>
            <option value="10" selected>10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="all">All</option>
        </select>
    </label>
    <div class="pager" data-table="unsubscribe-table">
        <button type="button" class="prev">Prev</button>
        <span class="page-info"></span>
        <button type="button" class="next">Next</button>
    </div>
</div>
<div class="table-wrapper" {% if not unsubscribe_records %}style="display:none;"{% endif %}>
    <table id="unsubscribe-table">
        <thead>
            <tr>
                <th class="sortable" data-sort-type="text">Email</th>
                <th class="sortable" data-sort-type="date">Unsubscribed At</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="unsubscribe-table-body">
            {% for record in unsubscribe_records %}
            <tr data-email="{{ record.email }}">
                <td data-sort-value="{{ record.email }}">{{ record.email }}</td>
                <td data-sort-value="{{ record.unsubscribed_at or '' }}">{{ record.unsubscribed_display or 'Unknown' }}</td>
                <td>
                    <form class="remove-form" method="post" action="{{ url_for('remove_email') }}" data-email="{{ record.email }}">
                        <input type="hidden" name="email" value="{{ record.email }}">
                        <button type="submit">Remove</button>
                    </form>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>
<p id="unsubscribe-empty" {% if unsubscribe_records %}class="hidden"{% endif %}>No unsubscribed emails yet.</p>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
(function() {
    const flashContainers = Array.from(document.querySelectorAll(".local-flashes"));
    flashContainers.forEach((localContainer) => {
        const localMessages = Array.from(localContainer.querySelectorAll(".message"));
        localMessages.forEach((msg) => {
            const closeBtn = msg.querySelector(".close-btn");
            const hide = () => msg.classList.add("hidden");
            setTimeout(hide, 30000);
            if (closeBtn) {
                closeBtn.addEventListener("click", () => {
                    msg.remove();
                    if (!localContainer.querySelector(".message")) {
                        localContainer.remove();
                    }
                });
            }
        });
    });

    const unsubscribeCard = document.getElementById("unsubscribe-card");
    if (unsubscribeCard) {
        const unsubscribeForm = document.getElementById("unsubscribe-form");
        const unsubscribeInput = document.getElementById("unsubscribe-email-input");
        const unsubscribeTable = document.getElementById("unsubscribe-table");
        const unsubscribeTableBody = document.getElementById("unsubscribe-table-body");
        const unsubscribeControls = unsubscribeCard.querySelector('.table-controls[data-table="unsubscribe-table"]');
        const unsubscribeWrapper = unsubscribeCard.querySelector('.table-wrapper');
        const unsubscribeEmpty = document.getElementById("unsubscribe-empty");
        const unsubscribeCount = document.getElementById("unsubscribe-count");

        const ensureLocalFlashes = () => {
            let flashes = unsubscribeCard.querySelector(".local-flashes");
            if (!flashes) {
                flashes = document.createElement("div");
                flashes.className = "local-flashes";
                unsubscribeCard.insertBefore(flashes, unsubscribeForm);
            }
            return flashes;
        };

        const pushUnsubscribeMessage = (type, text) => {
            const container = ensureLocalFlashes();
            const existingMessages = container.querySelectorAll(".message");
            existingMessages.forEach((msg) => msg.remove());
            const message = document.createElement("div");
            message.className = `message ${type}`;
            const span = document.createElement("span");
            span.textContent = text;
            const close = document.createElement("button");
            close.type = "button";
            close.className = "close-btn";
            close.setAttribute("aria-label", "Dismiss");
            close.textContent = "Ã—";
            close.addEventListener("click", () => message.remove());
            message.appendChild(span);
            message.appendChild(close);
            container.appendChild(message);
            setTimeout(() => message.classList.add("hidden"), 30000);
            setTimeout(() => message.remove(), 32000);
            unsubscribeCard.scrollIntoView({ behavior: "smooth", block: "start" });
        };

        const updateVisibility = () => {
            const hasRows = unsubscribeTableBody && unsubscribeTableBody.querySelector("tr");
            if (unsubscribeControls) {
                unsubscribeControls.style.display = hasRows ? "" : "none";
            }
            if (unsubscribeWrapper) {
                unsubscribeWrapper.style.display = hasRows ? "" : "none";
            }
            if (unsubscribeEmpty) {
                if (hasRows) {
                    unsubscribeEmpty.classList.add("hidden");
                } else {
                    unsubscribeEmpty.classList.remove("hidden");
                }
            }
        };

        const setCount = (value) => {
            if (unsubscribeCount) {
                unsubscribeCount.textContent = String(Math.max(0, value));
            }
        };

        const recalcCount = () => {
            const rows = unsubscribeTableBody ? unsubscribeTableBody.querySelectorAll("tr").length : 0;
            setCount(rows);
        };

        const buildRow = (data) => {
            const row = document.createElement("tr");
            row.dataset.email = data.email;

            const emailCell = document.createElement("td");
            emailCell.dataset.sortValue = data.email;
            emailCell.textContent = data.email;
            row.appendChild(emailCell);

            const dateCell = document.createElement("td");
            dateCell.dataset.sortValue = data.unsubscribed_at || "";
            dateCell.textContent = data.unsubscribed_display || data.unsubscribed_at || "Unknown";
            row.appendChild(dateCell);

            const actionCell = document.createElement("td");
            const form = document.createElement("form");
            form.className = "remove-form";
            form.method = "post";
            form.action = data.remove_url;
            form.dataset.email = data.email;
            const hidden = document.createElement("input");
            hidden.type = "hidden";
            hidden.name = "email";
            hidden.value = data.email;
            const button = document.createElement("button");
            button.type = "submit";
            button.textContent = "Remove";
            form.appendChild(hidden);
            form.appendChild(button);
            actionCell.appendChild(form);
            row.appendChild(actionCell);
            return row;
        };

        const attachRow = (row) => {
            if (!unsubscribeTableBody) {
                return;
            }
            const existing = unsubscribeTableBody.querySelector(`tr[data-email="${row.dataset.email}"]`);
            if (existing) {
                existing.replaceWith(row);
            } else {
                unsubscribeTableBody.appendChild(row);
            }
            const removeForm = row.querySelector(".remove-form");
            if (removeForm) {
                hookRemoveForm(removeForm);
            }
            if (unsubscribeTable && unsubscribeTable._fm) {
                unsubscribeTable._fm.refresh();
            }
            updateVisibility();
            recalcCount();
        };

        const removeRow = (email) => {
            if (!unsubscribeTableBody) {
                return;
            }
            const existing = unsubscribeTableBody.querySelector(`tr[data-email="${email}"]`);
            if (existing) {
                existing.remove();
                if (unsubscribeTable && unsubscribeTable._fm) {
                    unsubscribeTable._fm.refresh();
                }
            }
            updateVisibility();
            recalcCount();
        };

        const submitForm = async (form) => {
            const formData = new FormData(form);
            const response = await fetch(form.action, {
                method: form.method || "POST",
                body: formData,
                headers: {
                    "Accept": "application/json",
                    "X-Requested-With": "fetch"
                },
            });
            if (!response.ok) {
                throw new Error("Request failed");
            }
            return response.json();
        };

        const hookRemoveForm = (form) => {
            form.addEventListener("submit", async (event) => {
                event.preventDefault();
                try {
                    const data = await submitForm(form);
                    if (data.success) {
                        removeRow(data.email);
                        pushUnsubscribeMessage("success", data.message || `Removed ${data.email} from the unsubscribe list.`);
                    } else {
                        pushUnsubscribeMessage("error", data.message || "Unable to remove address.");
                    }
                } catch {
                    pushUnsubscribeMessage("error", "Failed to contact server. Please try again.");
                }
            });
        };

        if (unsubscribeForm) {
            unsubscribeForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                const form = event.currentTarget;
                const emailValue = (form.email.value || "").trim();
                if (!emailValue) {
                    return;
                }
                try {
                    const data = await submitForm(form);
                    if (data.success) {
                        const row = buildRow(data);
                        attachRow(row);
                        pushUnsubscribeMessage("success", data.message || `Added ${data.email} to the unsubscribe list.`);
                        form.reset();
                        if (unsubscribeInput) {
                            unsubscribeInput.focus({ preventScroll: true });
                        }
                    } else {
                        pushUnsubscribeMessage("error", data.message || "Unable to add address.");
                    }
                } catch {
                    pushUnsubscribeMessage("error", "Failed to contact server. Please try again.");
                }
            });
        }

        const existingRemoveForms = unsubscribeCard.querySelectorAll(".remove-form");
        existingRemoveForms.forEach(hookRemoveForm);

        updateVisibility();
        recalcCount();
    }

    initActionMenus();

    const configs = [
        { tableId: "todo-table", defaultSize: 10 },
        { tableId: "recent-table", defaultSize: 10 },
        { tableId: "unsubscribe-table", defaultSize: 10 }
    ];

    configs.forEach(({ tableId, defaultSize }) => initTable(tableId, defaultSize));

    function initTable(tableId, defaultSize) {
        const table = document.getElementById(tableId);
        if (!table) {
            return;
        }
        const tbody = table.tBodies[0];
        let rows = Array.from(tbody.querySelectorAll("tr"));
        let allRows = rows;
        let filteredRows = rows;

        const pager = document.querySelector(`.pager[data-table="${tableId}"]`);
        const pageInfo = pager ? pager.querySelector('.page-info') : null;
        const prevBtn = pager ? pager.querySelector('.prev') : null;
        const nextBtn = pager ? pager.querySelector('.next') : null;
        const sizeSelect = document.querySelector(`.page-size[data-table="${tableId}"]`);
        const searchInput = document.querySelector(`.table-search[data-table="${tableId}"]`);
        const filteredCount = document.querySelector(`.table-controls[data-table="${tableId}"] .filtered-count`);
        const headers = Array.from(table.querySelectorAll('thead th.sortable'));
        const sortState = { index: -1, direction: 'asc' };

        if (!sizeSelect) {
            return;
        }

        if (rows.length === 0) {
            sizeSelect.style.display = 'none';
            if (pager) { pager.style.display = 'none'; }
            if (searchInput) { searchInput.style.display = 'none'; }
            return;
        }

        const defaultValue = defaultSize === 'all' ? 'all' : String(defaultSize);
        sizeSelect.value = defaultValue;

        let pageSize = resolvePageSize(defaultValue);
        let currentPage = 1;
        let columnFilters = {};

        initSorting();
        initSearch();
        initColumnFilters();
        render();

        sizeSelect.addEventListener('change', (event) => {
            pageSize = resolvePageSize(event.target.value);
            currentPage = 1;
            render();
        });

        if (prevBtn) {
            prevBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage -= 1;
                    render();
                }
            });
        }

        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                const totalPages = pageSize === Infinity ? 1 : Math.max(1, Math.ceil(rows.length / pageSize));
                if (currentPage < totalPages) {
                    currentPage += 1;
                    render();
                }
            });
        }

        function resolvePageSize(value) {
            return value === 'all' ? Infinity : parseInt(value, 10);
        }

        function applyFilters() {
            let filtered = allRows;

            // Apply search filter
            if (searchInput && searchInput.value.trim()) {
                const query = searchInput.value.toLowerCase().trim();
                filtered = filtered.filter((row) => {
                    const text = row.textContent.toLowerCase();
                    return text.includes(query);
                });
            }

            // Apply column filters
            Object.keys(columnFilters).forEach((colIndex) => {
                const activeValues = columnFilters[colIndex];
                if (activeValues && activeValues.size > 0) {
                    filtered = filtered.filter((row) => {
                        const cell = row.cells[colIndex];
                        if (!cell) return false;
                        const value = (cell.textContent || '').trim();
                        return activeValues.has(value);
                    });
                }
            });

            filteredRows = filtered;
            rows = filtered;
            currentPage = 1;
            if (filteredCount) {
                filteredCount.textContent = filtered.length;
            }
            render();
        }

        function initSearch() {
            if (!searchInput) {
                return;
            }
            searchInput.addEventListener('input', () => {
                applyFilters();
            });
        }

        function initColumnFilters() {
            // Create backdrop element for mobile
            let backdrop = document.getElementById('filter-backdrop');
            if (!backdrop) {
                backdrop = document.createElement('div');
                backdrop.id = 'filter-backdrop';
                backdrop.className = 'filter-backdrop';
                document.body.appendChild(backdrop);

                backdrop.addEventListener('click', () => {
                    document.querySelectorAll('.filter-dropdown.open').forEach((d) => {
                        d.classList.remove('open');
                    });
                    backdrop.classList.remove('active');
                });
            }

            headers.forEach((header, columnIndex) => {
                // Skip action columns
                if (header.classList.contains('actions-col') || header.textContent.trim() === 'Actions') {
                    return;
                }

                const filterDropdown = document.createElement('div');
                filterDropdown.className = 'filter-dropdown';

                const filterTrigger = document.createElement('button');
                filterTrigger.className = 'filter-trigger';
                filterTrigger.innerHTML = '&#9662;';
                filterTrigger.type = 'button';
                filterTrigger.title = 'Filter';

                const filterMenu = document.createElement('div');
                filterMenu.className = 'filter-menu';

                const menuHeader = document.createElement('div');
                menuHeader.className = 'filter-menu-header';

                const selectAllBtn = document.createElement('button');
                selectAllBtn.textContent = 'All';
                selectAllBtn.type = 'button';

                const clearBtn = document.createElement('button');
                clearBtn.textContent = 'Clear';
                clearBtn.type = 'button';

                menuHeader.appendChild(selectAllBtn);
                menuHeader.appendChild(clearBtn);
                filterMenu.appendChild(menuHeader);

                const optionsContainer = document.createElement('div');
                filterMenu.appendChild(optionsContainer);

                filterDropdown.appendChild(filterTrigger);
                filterDropdown.appendChild(filterMenu);
                header.appendChild(filterDropdown);

                // Build unique values for this column
                function rebuildFilterOptions() {
                    const uniqueValues = new Set();
                    allRows.forEach((row) => {
                        const cell = row.cells[columnIndex];
                        if (cell) {
                            const value = (cell.textContent || '').trim();
                            if (value) uniqueValues.add(value);
                        }
                    });

                    const sortedValues = Array.from(uniqueValues).sort();
                    optionsContainer.innerHTML = '';

                    sortedValues.forEach((value) => {
                        const option = document.createElement('div');
                        option.className = 'filter-option';

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        const activeFilter = columnFilters[columnIndex];
                        checkbox.checked = !activeFilter || activeFilter.has(value);
                        checkbox.id = `filter-${tableId}-${columnIndex}-${value.replace(/[\s\.@\-]/g, '_')}`;

                        const label = document.createElement('label');
                        label.htmlFor = checkbox.id;
                        label.textContent = value;
                        label.title = value; // Add tooltip for long text

                        option.appendChild(checkbox);
                        option.appendChild(label);
                        optionsContainer.appendChild(option);

                        // Make the entire row clickable
                        option.addEventListener('click', (e) => {
                            // Prevent double-toggle when clicking checkbox directly
                            if (e.target === checkbox) {
                                return;
                            }
                            e.preventDefault();
                            checkbox.checked = !checkbox.checked;
                            updateColumnFilter(columnIndex);
                        });

                        // Handle checkbox change separately
                        checkbox.addEventListener('change', () => {
                            updateColumnFilter(columnIndex);
                        });
                    });
                }

                function updateColumnFilter(colIndex) {
                    const checkboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
                    const checkedValues = new Set();
                    let allChecked = true;

                    checkboxes.forEach((cb) => {
                        if (cb.checked) {
                            const label = cb.nextElementSibling;
                            checkedValues.add(label.textContent);
                        } else {
                            allChecked = false;
                        }
                    });

                    if (allChecked || checkedValues.size === 0) {
                        delete columnFilters[colIndex];
                        filterTrigger.classList.remove('active');
                    } else {
                        columnFilters[colIndex] = checkedValues;
                        filterTrigger.classList.add('active');
                    }

                    applyFilters();
                }

                filterTrigger.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const wasOpen = filterDropdown.classList.contains('open');

                    // Close all other filter dropdowns
                    document.querySelectorAll('.filter-dropdown.open').forEach((d) => {
                        d.classList.remove('open');
                    });

                    if (!wasOpen) {
                        rebuildFilterOptions();
                        filterDropdown.classList.add('open');
                        backdrop.classList.add('active');

                        // Position the dropdown dynamically
                        // Wait for next tick to ensure menu is visible for measurements
                        setTimeout(() => {
                            // Only apply positioning on desktop (not mobile)
                            if (window.innerWidth > 768) {
                                // Reset any previous inline styles first
                                filterMenu.style.position = '';
                                filterMenu.style.left = '0';
                                filterMenu.style.right = 'auto';
                                filterMenu.style.top = '';
                                filterMenu.style.maxWidth = '';

                                // Force a reflow to get accurate measurements
                                void filterMenu.offsetHeight;

                                const triggerRect = filterTrigger.getBoundingClientRect();
                                const viewportWidth = window.innerWidth;
                                const viewportHeight = window.innerHeight;
                                const padding = 16; // Buffer from viewport edges

                                // Use fixed positioning and clamp within the viewport to avoid clipping
                                const menuWidth = Math.min(filterMenu.offsetWidth, viewportWidth - (padding * 2));
                                const clampedLeft = Math.min(
                                    Math.max(padding, triggerRect.left),
                                    viewportWidth - menuWidth - padding
                                );
                                const availableHeight = Math.max(120, viewportHeight - triggerRect.bottom - padding);

                                filterMenu.style.position = 'fixed';
                                filterMenu.style.maxWidth = `${menuWidth}px`;
                                filterMenu.style.left = `${clampedLeft}px`;
                                filterMenu.style.right = 'auto';
                                filterMenu.style.top = `${triggerRect.bottom + 4}px`;
                                filterMenu.style.maxHeight = `${Math.min(availableHeight, 400)}px`;
                            } else {
                                // On mobile, clear any inline styles to let media query take over
                                filterMenu.style.position = '';
                                filterMenu.style.left = '';
                                filterMenu.style.right = '';
                                filterMenu.style.top = '';
                                filterMenu.style.maxWidth = '';
                                filterMenu.style.maxHeight = '';
                            }
                        }, 0);
                    } else {
                        backdrop.classList.remove('active');
                    }
                });

                selectAllBtn.addEventListener('click', () => {
                    optionsContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
                        cb.checked = true;
                    });
                    updateColumnFilter(columnIndex);
                });

                clearBtn.addEventListener('click', () => {
                    optionsContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
                        cb.checked = false;
                    });
                    updateColumnFilter(columnIndex);
                });

                document.addEventListener('click', (e) => {
                    if (!filterDropdown.contains(e.target)) {
                        const wasOpen = filterDropdown.classList.contains('open');
                        filterDropdown.classList.remove('open');
                        if (wasOpen) {
                            // Check if any dropdowns are still open
                            const anyOpen = document.querySelector('.filter-dropdown.open');
                            if (!anyOpen) {
                                backdrop.classList.remove('active');
                            }
                        }
                    }
                });
            });
        }

        function render() {
            const totalRows = rows.length;
            if (totalRows === 0) {
                if (pager) { pager.style.display = 'none'; }
                sizeSelect.style.display = 'none';
                if (pageInfo) { pageInfo.textContent = ''; }
                allRows.forEach((row) => {
                    row.style.display = 'none';
                });
                return;
            }
            sizeSelect.style.display = '';
            const totalPages = pageSize === Infinity ? 1 : Math.max(1, Math.ceil(totalRows / pageSize));
            if (currentPage > totalPages) {
                currentPage = totalPages;
            }
            const startIndex = pageSize === Infinity ? 0 : (currentPage - 1) * pageSize;
            const endIndex = pageSize === Infinity ? totalRows : startIndex + pageSize;

            allRows.forEach((row) => {
                row.style.display = 'none';
            });

            rows.forEach((row, index) => {
                row.style.display = index >= startIndex && index < endIndex ? '' : 'none';
            });

            if (pager && pageInfo) {
                if (totalPages <= 1) {
                    pager.style.display = 'none';
                } else {
                    pager.style.display = 'flex';
                    pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                    if (prevBtn) prevBtn.disabled = currentPage === 1;
                    if (nextBtn) nextBtn.disabled = currentPage === totalPages;
                }
            }
        }

        function initSorting() {
            if (!headers.length) {
                return;
            }
            headers.forEach((header, index) => {
                header.tabIndex = 0;
                header.addEventListener('click', () => toggleSort(index, header.dataset.sortType || 'text'));
                header.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        toggleSort(index, header.dataset.sortType || 'text');
                    }
                });
            });
        }

        function toggleSort(columnIndex, sortType) {
            const nextDirection =
                sortState.index === columnIndex && sortState.direction === 'asc' ? 'desc' : 'asc';
            sortState.index = columnIndex;
            sortState.direction = nextDirection;

            updateHeaderStates(columnIndex, nextDirection);

            allRows.sort((a, b) => compareRows(a, b, columnIndex, sortType, nextDirection));
            allRows.forEach((row) => tbody.appendChild(row));

            // Re-apply all filters after sorting
            applyFilters();
        }

        function updateHeaderStates(activeIndex, direction) {
            headers.forEach((header, index) => {
                if (index === activeIndex) {
                    header.setAttribute('aria-sort', direction === 'asc' ? 'ascending' : 'descending');
                    header.classList.remove('sort-asc', 'sort-desc');
                    header.classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                } else {
                    header.removeAttribute('aria-sort');
                    header.classList.remove('sort-asc', 'sort-desc');
                }
            });
        }

        function compareRows(rowA, rowB, columnIndex, sortType, direction) {
            const valueA = extractValue(rowA, columnIndex);
            const valueB = extractValue(rowB, columnIndex);
            const multiplier = direction === 'asc' ? 1 : -1;

            if (sortType === 'number') {
                const aNum = parseFloat(valueA);
                const bNum = parseFloat(valueB);
                if (!Number.isNaN(aNum) || !Number.isNaN(bNum)) {
                    const safeA = Number.isNaN(aNum) ? (direction === 'asc' ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY) : aNum;
                    const safeB = Number.isNaN(bNum) ? (direction === 'asc' ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY) : bNum;
                    return (safeA - safeB) * multiplier;
                }
            }

            if (sortType === 'date') {
                const timeA = parseDate(valueA);
                const timeB = parseDate(valueB);
                if (!Number.isNaN(timeA) || !Number.isNaN(timeB)) {
                    const safeA = Number.isNaN(timeA) ? (direction === 'asc' ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY) : timeA;
                    const safeB = Number.isNaN(timeB) ? (direction === 'asc' ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY) : timeB;
                    return (safeA - safeB) * multiplier;
                }
            }

            return valueA.localeCompare(valueB, undefined, { sensitivity: 'base' }) * multiplier;
        }

        function extractValue(row, columnIndex) {
            const cell = row.cells[columnIndex];
            if (!cell) {
                return '';
            }
            const value = cell.dataset.sortValue ?? cell.textContent;
            return (value || '').trim();
        }

        function parseDate(value) {
            if (!value) {
                return Number.NaN;
            }
            const normalized = value.includes('T') ? value : value.replace(' ', 'T');
            return Date.parse(normalized);
        }
        table._fm = {
            refresh() {
                allRows = Array.from(tbody.querySelectorAll("tr"));
                // Re-apply all filters
                applyFilters();
            }
        };
    }

    function initActionMenus() {
        const menus = Array.from(document.querySelectorAll(".action-menu"));
        if (!menus.length) {
            return;
        }

        let openMenu = null;

        function resetDoubleConfirm(menu) {
            if (!menu) {
                return;
            }
            const buttons = menu.querySelectorAll('.menu-item-button[data-double-confirm="true"]');
            buttons.forEach((button) => {
                if (button.dataset.originalText) {
                    button.textContent = button.dataset.originalText;
                }
                button.classList.remove('confirming');
                delete button.dataset.confirmState;
            });
        }

        function closeMenu(menu) {
            if (!menu) {
                return;
            }
            resetDoubleConfirm(menu);
            menu.classList.remove("open");
            const trigger = menu.querySelector(".menu-trigger");
            if (trigger) {
                trigger.setAttribute("aria-expanded", "false");
            }
            if (openMenu === menu) {
                openMenu = null;
            }
        }

        function openMenuFor(menu, trigger) {
            if (openMenu && openMenu !== menu) {
                closeMenu(openMenu);
            }
            openMenu = menu;
            menu.classList.add("open");
            if (trigger) {
                trigger.setAttribute("aria-expanded", "true");
            }
            const firstItem = menu.querySelector(".menu-item-button");
            if (firstItem) {
                firstItem.focus();
            }
        }

        menus.forEach((menu) => {
            const trigger = menu.querySelector(".menu-trigger");
            const dropdown = menu.querySelector(".menu-dropdown");
            if (!trigger || !dropdown) {
                return;
            }
            menu.addEventListener("click", (event) => event.stopPropagation());
            trigger.addEventListener("click", (event) => {
                event.preventDefault();
                if (menu.classList.contains("open")) {
                    closeMenu(menu);
                } else {
                    openMenuFor(menu, trigger);
                }
            });
            trigger.addEventListener("keydown", (event) => {
                if (event.key === "Enter" || event.key === " ") {
                    event.preventDefault();
                    if (menu.classList.contains("open")) {
                        closeMenu(menu);
                    } else {
                        openMenuFor(menu, trigger);
                    }
                }
            });
            dropdown.addEventListener("keydown", (event) => {
                if (event.key === "Escape") {
                    event.preventDefault();
                    closeMenu(menu);
                    trigger.focus();
                }
            });
        });

        document.addEventListener("click", (event) => {
            if (!openMenu) {
                return;
            }
            if (!openMenu.contains(event.target)) {
                closeMenu(openMenu);
            }
        });

        document.addEventListener("keydown", (event) => {
            if (event.key === "Escape" && openMenu) {
                closeMenu(openMenu);
            }
        });

        const actionForms = Array.from(document.querySelectorAll(".menu-item-form"));
        actionForms.forEach((form) => {
            const button = form.querySelector(".menu-item-button");
            const doubleConfirm = button && button.dataset.doubleConfirm === "true";
            const confirmMessage = form.dataset.confirm;

            if (doubleConfirm && button) {
                button.addEventListener("click", (event) => {
                    if (button.dataset.confirmState === "armed") {
                        if (button.dataset.originalText) {
                            button.textContent = button.dataset.originalText;
                        }
                        button.classList.remove("confirming");
                        delete button.dataset.confirmState;
                        return;
                    }
                    event.preventDefault();
                    button.dataset.originalText = button.dataset.originalText || button.textContent;
                    button.dataset.confirmState = "armed";
                    button.textContent = button.dataset.secondText || "Are you sure?";
                    button.classList.add("confirming");
                });
            }

            form.addEventListener("submit", (event) => {
                if (confirmMessage && !window.confirm(confirmMessage)) {
                    event.preventDefault();
                    return;
                }
                if (openMenu) {
                    closeMenu(openMenu);
                }
            });
        });
    }
})();
</script>
{% endblock %}
